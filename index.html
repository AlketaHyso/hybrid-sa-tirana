<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hybrid Greedy + SA – Tirana (Seeded Mobile Version)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    header { padding: 10px; background: #0b5394; color: white; text-align: center; }
    main { padding: 10px; }
    #controls { margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background-color: #0b5394;
      color: white;
      font-size: 14px;
    }
    button:disabled { background-color: #999; cursor: not-allowed; }
    #map { width: 100%; height: 450px; margin-top: 10px; border: 1px solid #ccc; }
    #output { margin-top: 10px; font-size: 14px; line-height: 1.4; }
    #route-list {
      margin-top: 5px;
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 5px;
    }
    .small { font-size: 12px; color: #555; }
  </style>
</head>

<body>
<header>
  <h2>Hybrid Greedy + SA – Tirana (31-point route, seeded)</h2>
</header>

<main>
  <div id="controls">
    <button id="runBtn">Run Hybrid Greedy + SA</button>
  </div>

  <div id="output">
    <div><strong>Status:</strong> <span id="status">Ready.</span></div>
    <div>
      <strong>Execution time:</strong> <span id="time">-</span><br>
      <span class="small">
        Execution time is measured directly on this mobile device using
        <code>performance.now()</code>, the high-resolution timer provided by the browser engine.
      </span>
    </div>
    <div><strong>Total distance:</strong> <span id="dist">-</span></div>
    <div id="route-list"></div>
  </div>

  <div id="map"></div>
</main>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  // ===================== 1. Points list (L3 – 31 locations) =====================
  const L3 = [
    ["Kalaja", [41.3275, 19.8189]],
    ["Muzeu Historik", [41.3305, 19.8189]],
    ["Parku i Qytetit", [41.3161, 19.8271]],
    ["Teatri Kombëtar", [41.3270, 19.8198]],
    ["Sheshi Kryesor", [41.3280, 19.8200]],
    ["Katedralja", [41.3285, 19.8208]],
    ["Pazari i Ri", [41.3308, 19.8223]],
    ["Stadiumi Air Albania", [41.3191, 19.8167]],
    ["Biblioteka Qendrore", [41.3278, 19.8197]],
    ["Galeria e Arteve", [41.3279, 19.8195]],
    ["Tregu Tradicional", [41.3282, 19.8215]],
    ["Ura e Vjetër", [41.3260, 19.8140]],
    ["Amfiteatri", [41.3290, 19.8230]],
    ["Kopshti Botanik", [41.3220, 19.8280]],
    ["Liqeni Artificial", [41.3150, 19.8240]],
    ["Qendra Tregtare", [41.3310, 19.8205]],
    ["Xhamia e Vjetër", [41.3295, 19.8190]],
    ["Kisha Mesjetare", [41.3288, 19.8185]],
    ["Monumenti i Lirisë", [41.3272, 19.8210]],
    ["Tregu i Vjetër", [41.3300, 19.8235]],
    ["Muzeu i Artit", [41.3265, 19.8202]],
    ["Shtëpia e Pavarësisë", [41.3258, 19.8197]],
    ["Kampi Veror", [41.3215, 19.8260]],
    ["Parku i Shpendëve", [41.3195, 19.8290]],
    ["Kështjella Romake", [41.3277, 19.8178]],
    ["Galeria Moderne", [41.3283, 19.8204]],
    ["Kinema Historike", [41.3298, 19.8212]],
    ["Qyteti i Vjetër", [41.3270, 19.8225]],
    ["Burimi Natyror", [41.3230, 19.8255]],
    ["Shkolla e Parë", [41.3262, 19.8194]],
    ["Ujëvara", [41.3187, 19.8132]]
  ];

  const numPoints = L3.length;
  const names = L3.map(p => p[0]);
  const coords = L3.map(p => p[1]);

  // ===================== 2. Seeded PRNG (LCG) =====================
  function LCG(seed) {
    let state = seed % 2147483647;
    if (state <= 0) state += 2147483646;

    return function () {
      state = (state * 16807) % 2147483647;
      return (state - 1) / 2147483646;
    };
  }

  function randInt(max, rng) {
    return Math.floor(rng() * max);
  }

  function randomSample2(n, rng) {
    let i = randInt(n, rng);
    let j = randInt(n, rng);
    while (j === i) {
      j = randInt(n, rng);
    }
    if (i > j) {
      const tmp = i;
      i = j;
      j = tmp;
    }
    return [i, j];
  }

  // ===================== 3. Haversine & distance matrix =====================
  function haversine_m(lat1, lon1, lat2, lon2) {
    const R = 6371000.0;
    const toRad = x => (x * Math.PI) / 180.0;

    const phi1 = toRad(lat1);
    const phi2 = toRad(lat2);
    const dphi = toRad(lat2 - lat1);
    const dlambda = toRad(lon2 - lon1);

    const sinDphi2 = Math.sin(dphi / 2);
    const sinDlambda2 = Math.sin(dlambda / 2);

    const a =
      sinDphi2 * sinDphi2 +
      Math.cos(phi1) * Math.cos(phi2) * sinDlambda2 * sinDlambda2;

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  const distMatrix = Array.from({ length: numPoints }, () =>
    Array(numPoints).fill(0)
  );

  for (let i = 0; i < numPoints; i++) {
    const [lat1, lon1] = coords[i];
    for (let j = 0; j < numPoints; j++) {
      if (i === j) {
        distMatrix[i][j] = 0.0;
      } else {
        const [lat2, lon2] = coords[j];
        distMatrix[i][j] = haversine_m(lat1, lon1, lat2, lon2);
      }
    }
  }

  function pairCost(u, v) {
    return distMatrix[u][v];
  }

  function routeCost(route) {
    let tot = 0.0;
    const n = route.length;
    for (let i = 0; i < n; i++) {
      const a = route[i];
      const b = route[(i + 1) % n];
      tot += pairCost(a, b);
    }
    return tot;
  }

  // ===================== 4. Greedy init =====================
  function greedyInitRoute(start = 0) {
    const unvis = new Set();
    for (let i = 0; i < numPoints; i++) {
      unvis.add(i);
    }
    const route = [start];
    unvis.delete(start);
    let cur = start;

    while (unvis.size > 0) {
      let bestJ = null;
      let bestD = Infinity;
      for (const j of unvis) {
        const d = pairCost(cur, j);
        if (d < bestD) {
          bestD = d;
          bestJ = j;
        }
      }
      route.push(bestJ);
      unvis.delete(bestJ);
      cur = bestJ;
    }
    return route;
  }

  // ===================== 5. Hybrid Greedy + SA with tracking =====================
  function runHybridGreedySATracked(temperature, coolingRate, logEvery, seedVal) {
    const rng = LCG(seedVal);

    let currentRoute = greedyInitRoute(0);
    let bestRoute = currentRoute.slice();
    let bestDist = routeCost(bestRoute);

    let T = temperature;
    const history = [bestDist];
    let steps = 0;

    while (T > 1) {
      const newRoute = currentRoute.slice();
      const [i, j] = randomSample2(numPoints, rng);
      const segment = newRoute.slice(i, j).reverse();
      for (let k = i; k < j; k++) {
        newRoute[k] = segment[k - i];
      }

      const currDist = routeCost(currentRoute);
      const newDist = routeCost(newRoute);

      if (
        newDist < currDist ||
        rng() < Math.exp((currDist - newDist) / T)
      ) {
        currentRoute = newRoute;
        if (newDist < bestDist) {
          bestDist = newDist;
          bestRoute = newRoute.slice();
        }
      }

      steps += 1;
      if (steps % logEvery === 0) {
        history.push(bestDist);
      }

      T *= coolingRate;
    }

    if (history[history.length - 1] !== bestDist) {
      history.push(bestDist);
    }

    return { bestRoute, bestDist, history };
  }

  function runManyHybrid(nRuns, temperature, coolingRate, logEvery) {
    let bestGlobalRoute = null;
    let bestGlobalDist = Infinity;
    let bestGlobalHist = null;
    let bestSeed = null;

    for (let r = 0; r < nRuns; r++) {
      const seedVal = 2025 + r;
      const { bestRoute, bestDist, history } =
        runHybridGreedySATracked(temperature, coolingRate, logEvery, seedVal);

      console.log(
        `[Hybrid Greedy+SA] run ${r + 1}/${nRuns} | seed=${seedVal} | best=${bestDist.toFixed(
          2
        )} m`
      );

      if (bestDist < bestGlobalDist) {
        bestGlobalDist = bestDist;
        bestGlobalRoute = bestRoute;
        bestGlobalHist = history;
        bestSeed = seedVal;
      }
    }

    return { bestGlobalRoute, bestGlobalDist, bestGlobalHist, bestSeed };
  }

  // ===================== 6. Leaflet map =====================
  const map = L.map("map");
  const centerLat = coords.reduce((acc, c) => acc + c[0], 0) / coords.length;
  const centerLon = coords.reduce((acc, c) => acc + c[1], 0) / coords.length;

  map.setView([centerLat, centerLon], 14);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors"
  }).addTo(map);

  let routeLayer = null;
  let markerLayerGroup = L.layerGroup().addTo(map);

  function drawRoute(route) {
    if (routeLayer) {
      map.removeLayer(routeLayer);
    }
    markerLayerGroup.clearLayers();

    const latlngs = [];
    for (const idx of route) {
      const [lat, lon] = coords[idx];
      latlngs.push([lat, lon]);
      const marker = L.marker([lat, lon]).bindPopup(names[idx]);
      markerLayerGroup.addLayer(marker);
    }
    const [lat0, lon0] = coords[route[0]];
    latlngs.push([lat0, lon0]);

    routeLayer = L.polyline(latlngs, { weight: 3 }).addTo(map);
    map.fitBounds(routeLayer.getBounds(), { padding: [30, 30] });
  }

  // ===================== 7. UI logic =====================
  const runBtn = document.getElementById("runBtn");
  const statusSpan = document.getElementById("status");
  const timeSpan = document.getElementById("time");
  const distSpan = document.getElementById("dist");
  const routeListDiv = document.getElementById("route-list");

  runBtn.addEventListener("click", () => {
    statusSpan.textContent = "Running...";
    runBtn.disabled = true;
    routeListDiv.textContent = "";
    timeSpan.textContent = "-";
    distSpan.textContent = "-";

    const t0 = performance.now();
    const { bestGlobalRoute, bestGlobalDist } =
      runManyHybrid(
        30,      // nRuns
        5000.0,  // temperature
        0.996,   // coolingRate
        100      // logEvery
      );
    const t1 = performance.now();
    const elapsedSec = (t1 - t0) / 1000.0;

    statusSpan.textContent = "Finished.";
    timeSpan.textContent = elapsedSec.toFixed(4) + " s";
    distSpan.textContent =
      bestGlobalDist.toFixed(2) +
      " m (" +
      (bestGlobalDist / 1000.0).toFixed(3) +
      " km)";

    let html = "<strong>Best route (indices → names):</strong><br/>";
    bestGlobalRoute.forEach((idx, i) => {
      html +=
        (i + 1) +
        ". [" +
        idx +
        "] " +
        names[idx] +
        " (" +
        coords[idx][0].toFixed(5) +
        ", " +
        coords[idx][1].toFixed(5) +
        ")<br/>";
    });
    const firstIdx = bestGlobalRoute[0];
    html +=
      "Return to: [" +
      firstIdx +
      "] " +
      names[firstIdx] +
      " (" +
      coords[firstIdx][0].toFixed(5) +
      ", " +
      coords[firstIdx][1].toFixed(5) +
      ")";
    routeListDiv.innerHTML = html;

    drawRoute(bestGlobalRoute);

    runBtn.disabled = false;
  });
</script>
</body>
</html>
